# TP 02

Afin de réglé mon problème de nom de ma clé. J'ai tout simplement renommer le fichier `id_rsa` afin qu'il ne soit plus lancé par défaut.

Je ne l'avais pas précisé précedemment mais les attaques brute force ssh consiste en :

Une tentative de quelqu'un plus ou moins bien intentioné de pénétrer sur votre machine à l'aide de ssh. Pour ce faire l'attaquant va essayer de se connecter sur différente adresse en ssh, beaucoup d'adresses. Afin de se connecter il va utiliser un dictionnaire de login/mot de passe usuels.

La première partie du tp 02 était expliqué dans le ReadMe `tp01.md`.

Je vais donc reprendre ce TP à partir de la partie 2 sur les processus.

# 2 Processus

## Etude des processus Unix

À partir d'ici j'executerai l'ensemble des commandes dans ma machine virtuelle via ssh.

### 1 La commande ps

La commande `ps` renvoie :

```
root@serveur1:~# ps
    PID TTY          TIME CMD
    585 pts/0    00:00:00 su
    586 pts/0    00:00:00 bash
    592 pts/0    00:00:00 ps
```

`ps aux` me renvoie un resultat plus complet :

- a = montre les processus pour tout les utilisateurs
- u = montre l'utilisateur qui à lancé le processus
- x = montre les processus détaché d'un terminal

Cette commande permet de lister les processus actif sur la machine.

- La colonne `TIME` correspond au temps CPU total utilisé par le processus depuis son démarrage.

- La commande `top` affiche en temps réel l'utilisation des ressources des processus :

Les processus qui utilisent le plus le CPU sont : top, systemd et sshd. Mais toutes les 3 ne l'utilisent même pas à 1%.

Le premier processus est `init` et non pas `sytemd` il faut croire que ça à encore changer .... je peux le voir à l'aide de `ps aux` :

```
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.6 102052 12140 ?        Ss   14:36   0:00 /sbin/init
```

On sait que c'est le premier processus car son PID est 1.

Ma machine s'est lancé à 14:36 je peux le voir la mais également à l'aide de la commande `who -b` avec l'option b pour "boot" :

```
root@serveur1:~# who -b
         démarrage système 2024-10-09 14:36
```

À l'aide de la commande `ps aux | wc -l` je peux compter le nombre de lignes que `ps aux` me renvoie :

```
root@serveur1:~# ps aux | wc -l
88
```

On doit retirer une ligne car la première ligne de la commande correspond à la légende :

```
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND

```

J'avais mal lu la question et je croyais que c'étais les processus en cours. Il s'avère que c'est le nombre de processus depuis le lancement de la machine.

J'ai donc 88 processus actif. Le nombre de processus lancé depuis le démarrage est accessible avec `ps aux` en regardant le PID le plus élevé ici c'est 1428. Ce nombre est très élevé car j'ai repris cette question en fin de séance et donc que j'ai lancé pleins de processus depuis.

### Les PPID

À l'aide de la commande `ps -ef` je peux avoir des informations supplémentaires tels que le PID du processus parent.

En regardant les PID des processus parent je peux remonter l'aborescence entière :

```
NOM                           PID  PPID
ps -ef                        918  914
-bash                         914  898
sshd: root@pts/1              898  502
sshd: /usr/sbin/sshd -D [lis  502  1
/sbin/init                    1    0
```

À savoir que le nom du 3 ème parent est surement coupé par mon terminal.

### 3 pstree

J'ai installé `pstree` à l'aide de la commande `apt-get install psmisc` une fois lancée cela me donne :

```
root@serveur1:~# pstree
systemd─┬─cron
        ├─dbus-daemon
        ├─dhclient
        ├─login───bash───su───bash
        ├─sshd─┬─sshd───sshd───bash───su───bash
        │      └─sshd───bash───pstree
```

Le chemin est assez similiare sachant que `systemd` et `init` sont équivalents.

### 4 top

J'avais déjà utilisé `top`, mais à l'aide de `SHIFT+M` je peux trier de manière décroissante sur l'utilisation de la mémoire.

```
    PID UTIL.     PR  NI    VIRT    RES    SHR S  %CPU  %MEM    TEMPS+ COM.
      1 root      20   0  102052  12144   9176 S   0,0   0,6   0:00.57 systemd
    575 root      20   0   17820  11096   9480 S   0,0   0,6   0:00.05 sshd
    898 root      20   0   18004  11072   9232 S   0,0   0,5   0:00.17 sshd
    210 root      20   0   49356  11068   7892 S   0,0   0,5   0:00.20 systemd-journal
```

Pas étonnant mais c'est `systemd` qui est le plus "gourmand".

- `z` me permet d'activer la couleur.
- `SHIFT+i` Mettre en avant la colonne de tri
- `SHIFT+f` Changer la colonne de tri sélectionner la colonne avec les flèches, puis `d` pour activer/désactiver, et `Enter` pour confirmer.

`htop` me permet de voir des informations similaires mais différement.

Avantages :

- Interface colorée plus agréable
- COmmande kill directement intégré à htop
- Supporte la souris

Inconvénient :

- Supporte la souris (Oui pour certains c'est un desavantage)
- consomme plus de ressource

# 3 Arret d'un processus

À l'aide de `ps` et de la commande `kill` je peux identifier les processus en fond et mettre fin à ces processus à l'aide de `-9` qui correspond au signal `SIGKILL`.

```
root@serveur1:~# ps
    PID TTY          TIME CMD
   1222 pts/1    00:00:00 bash
   1391 pts/1    00:00:00 sh
   1398 pts/1    00:00:00 sleep
   1405 pts/1    00:00:00 sh
   1412 pts/1    00:00:00 sleep
   1413 pts/1    00:00:00 ps
root@serveur1:~# kill -9 1391
root@serveur1:~# ps
    PID TTY          TIME CMD
   1222 pts/1    00:00:00 bash
   1405 pts/1    00:00:00 sh
   1412 pts/1    00:00:00 sleep
   1414 pts/1    00:00:00 ps
[1]-  Processus arrêté      sh date.sh
root@serveur1:~# kill -9 1405
```

Le premier script affiche l'heure. Le deuxième affiche toto + l'heure mais retire 5 heure à l'heure actuel.

# 4 Les tubes

La commande `cat` est utilisée pour afficher le contenu d'un fichier ou de plusieurs fichiers sur la sortie standard. Elle peut également être utilisée pour concatener des fichiers.

La commande `tee`, quant à elle, est utilisée pour doubler la sortie d'un programme. Elle écrit la sortie à la fois sur la sortie standard et dans un fichier spécifié.

- `ls | cat` affiche le resultat de `ls` en redirigant le resultat vers `cat`. Concretement cela ne change pas grand chose dans cet exemple précis.

- `ls -l | cat > liste` : l'option `-l` utilise un format d'affichage long. Comme on l'as vu précedemment le résultat est redirigé vers `cat`. L'opérateur de redirection `>` envoie la sortie de cat vers un fichier nommé `liste`.
- `ls -l | tee liste` : Nous avons précedemment vu le `-l`. La resultat est ensuite transmis à `tee` qui va afficher le resultat dans le terminal(car c'est la sortie standard par défaut). Et il l'écrit dans un fichier liste.

- `ls -l | tee liste | wc -l` : `-l` toujours pareil `tee` duplique cette sortie : Il l'affiche dans le terminal. Il l'écrit dans le fichier `liste`. Puis le nouveau pipe recoit la sortie de tee.`wc -l` sert à compter le nombre de ligne. L'effet pour résumé : le résultat de `ls -l` est affiché dans le terminal, sauvegardé dans liste à l'aide de `tee` , et le terminal affiche également le nombre de lignes à l'aide de `wc -l`.

# 5 Journal système rsyslog

Je n'avais pas `rsyslog` dans mon système après installation j'ai vérifié qu'il était installé à l'aide de `grep`.

```
root@serveur1:~# ps aux | grep "rsyslog"
root        2074  0.0  0.3 221788  6228 ?        Ssl  13:27   0:00 /usr/sbin/rsyslogd -n -iNONE
root        2098  0.0  0.1   6352  2200 pts/1    S+   13:27   0:00 grep rsyslog
```

C'est le processus 2074 l'autre résultat correspond à ma commande `grep`.

Dans le fichier `.conf` on peux voir que les fichier de logs sont écris dans : `$WorkDirectory /var/spool/rsyslog`.

Cependant dans mon dossier rsyslog je n'ai rien :

```
root@serveur1:/var/spool/rsyslog# ls -la
total 8
drwx------ 2 root root 4096 22 févr.  2023 .
drwxr-xr-x 5 root root 4096 11 oct.  13:27 ..

```

Même après redémarrage pareiL. Ce résultat est étonnant pourtant le service est bien actif après vérification avec `systemctl`.

J'ai lu sur la documentation debian quelque chose d'intéressant à ce sujet : https://wiki.debian.org/fr/Rsyslog

"
A partir de Bookworm, le "journal" persistant de Systemd a été activé et la plupart des messages se retrouvaient écrits deux fois sur le disque. Il a été alors décidé que le paquet rsyslog verrait sa priorité baissée de Important à Optionnal, ce qui signifie qu'il n'est plus installé par défaut dans un système de base Debian
"

Cependant le but du tp est j'imagine de nous faire decouvrir les logs sur Debian. Ces derniers permettent de recenser toute activité sur une machine et ainsi d'avoir des traces en cas de problèmes. Par exemple sur Debian le fichier `/var/log/auth.log` contient les logs de connexion ou de déconnexion. J'ai donc fait la commande `tail -f /var/log/auth.log` pour observer le contenu du fichier de log.

Il ne me reste plus qu'a lancer un second terminal et me connecter en ssh voir si cette connexion laisse une trace.

Meme si ce n'est pas très lisible à l'oeil nu. J'ai fait des grands espace pour distinguer mon arrivé depuis le second terminal. On voit donc que je me suis connecté et à mon arrivée une serie de message à recensé cette connexion.

```
root@serveur1:~# tail -f /var/log/auth.log
2024-10-11T15:42:50.749032+02:00 serveur1 systemd-logind[462]: Removed session 8.
2024-10-11T15:42:55.360979+02:00 serveur1 sshd[871]: Accepted publickey for root from 10.0.2.2 port 53800 ssh2: RSA SHA256:+Bw4O0pbpQaGcD1NkMbEZHiKdtgmQIy0gBvW8olemaY
2024-10-11T15:42:55.362327+02:00 serveur1 sshd[871]: pam_unix(sshd:session): session opened for user root(uid=0) by (uid=0)
2024-10-11T15:42:55.373665+02:00 serveur1 systemd-logind[462]: New session 9 of user root.
2024-10-11T15:42:55.380888+02:00 serveur1 sshd[871]: pam_env(sshd:session): deprecated reading of user environment enabled
2024-10-11T15:43:25.571868+02:00 serveur1 sshd[871]: Received disconnect from 10.0.2.2 port 53800:11: disconnected by user
2024-10-11T15:43:25.573179+02:00 serveur1 sshd[871]: Disconnected from user root 10.0.2.2 port 53800
2024-10-11T15:43:25.574285+02:00 serveur1 sshd[871]: pam_unix(sshd:session): session closed for user root
2024-10-11T15:43:25.579481+02:00 serveur1 systemd-logind[462]: Session 9 logged out. Waiting for processes to exit.
2024-10-11T15:43:25.584157+02:00 serveur1 systemd-logind[462]: Removed session 9.





2024-10-11T15:53:53.436688+02:00 serveur1 sshd[921]: Accepted publickey for root from 10.0.2.2 port 37850 ssh2: RSA SHA256:+Bw4O0pbpQaGcD1NkMbEZHiKdtgmQIy0gBvW8olemaY
2024-10-11T15:53:53.449004+02:00 serveur1 sshd[921]: pam_unix(sshd:session): session opened for user root(uid=0) by (uid=0)
2024-10-11T15:53:53.450133+02:00 serveur1 systemd-logind[462]: New session 10 of user root.
2024-10-11T15:53:53.457794+02:00 serveur1 sshd[921]: pam_env(sshd:session): deprecated reading of user environment enabled
```

On peu donc voir que je me suis connecté avec ma clé ssh. Ainsi ces "logs" ou journaux en francais permettent de recenser toutes activités sur une machine.
