# Paramètres

Voici le script `analyse.sh`:

- On instancie une variable nombre de paramètres qui récupère cette valeur à l'aide de `$#`.

- Le nom du script se récupère à l'aide de `$(basename "$0")`

(cf : https://stackoverflow.com/questions/192319/how-do-i-know-the-script-file-name-in-a-bash-script)

- Le i-ème paramètre se récupère à l'aide de `${i}`.

- Finalement à l'aide de `echo` et de `$ma_variable` on peut afficher l'ensemble des données.

```
#!/bin/bash

# Nombre de paramètres
nombre_parametres=$#

# Nom du script
nom_script=$(basename "$0")

# Troisième paramètre
troisieme_parametre=${3}

# Affichage des informations
echo "Bonjour, vous avez rentré $nombre_parametres paramètres."
echo "Le nom du script est $nom_script"
echo "Le 3ème paramètre est $troisieme_parametre."
echo "Voici la liste des paramètres : $*"

exit 0
```

Et voici le résultat du script :

```
root@serveur1:~# sh analyse.sh toto tata tutu
Bonjour, vous avez rentré 3 paramètres.
Le nom du script est analyse.sh
Le 3ème paramètre est tutu.
Voici la liste des paramètres : toto tata tutu
```

# Verification du nombre de paramètre :

- Je commence par vérifier que le nombre d'argument donnée en entrée (`$#`) est différent de 2 : `-ne 2` ne voulant dire "not equal". Si c'est le cas, alors je lance une erreur avec `echo` et j'arrete l'execution du programme à l'aide de `exit 1`. 1 veut dire qu'il y a eu une erreur et 0 qu'il n'y en as pas.

- ensuite je déclare une variable `CONCAT` même si j'aurais pu directement retourner le résultat. Ma variable contient juste le premier argument et le second collé dans une chaine de caractère.

- J'affiche enfin le résultat à l'aide de `echo`.

```
#!/bin/bash

# Vérification du nombre de paramètres > 2
if [ "$#" -ne 2 ]; then
  echo "Usage: <word1> <word2>"
  exit 1
fi

# Concaténation des deux mots
CONCAT="$1$2"

# Affichage du résultat
echo "Résultat : $CONCAT"

exit 0
```

Ce script me renvoie :

```
root@serveur1:~# sh concat.sh toto
Usage: <word1> <word2>.
root@serveur1:~# sh concat.sh toto tutu
Résultat : tototutu
```

# Argument type et droits

- Premièrement on vérifie le nombre d'arguments.
- puis on instance quelques variable : le path, le nom du script, et le futur resultat.
- Ensuite à l'aide d'une serie de if on va vérifier si le paramètre est un fichier ou un dossier. Si c'est un fichier on vérifiera si il est vide ou non.
- Ensuite on va vérifier si le fichier est accessible en lecture, execution et en écriture pour root. Pour dev qui est mon user de base si il est accessible en lecture.

```
#!/bin/bash

# Vérification des arguments
if [ "$#" -ne 1 ]; then
  echo ""Usage: <file|repertory>"
  exit 1
fi

# Nom du fichier ou répertoire
path="$1"

# Nom du script
nom_script=$(basename "$0")
res=""

# Vérification si c'est un fichier ou un répertoire
if [ -f "$path" ]; then
  res="$path est un fichier ordinaire"
  if [ ! -s "$path" ]; then
    res="$res et est vide"
  else
    res="$res et n'est pas vide"
  fi
elif [ -d "$path" ]; then
  res="$path est un répertoire"
else
  res="$path n'est ni un fichier ordinaire ni un répertoire"
fi

# Vérification des permissions pour root
if [ -r "$path" ] && [ -w "$path" ] && [ -x "$path" ]; then
  res="$res\n\"$path\" est accessible par root en lecture, écriture, et exécution"
else
  res="$res\n\"$path\" n'est pas totalement accessible par root"
fi

# Vérification des permissions pour l'utilisateur "dev"
if sudo -u dev [ -r "$path" ]; then
  res="$res\n\"$path\" est accessible par dev en lecture"
else
  res="$res\n\"$path\" n'est pas accessible par dev en lecture"
fi

# Affichage du résultat final
echo "$res"

exit 0


```

Le resultat de ce script est :

```
root@serveur1:~# sh test-fichier.sh date.sh
date.sh est un fichier ordinaire et n'est pas vide
"date.sh" n'est pas totalement accessible par root
"date.sh" n'est pas accessible par dev en lecture
root@serveur1:~# sh test-fichier.sh repertory/
repertory/ est un répertoire
"repertory/" est accessible par root en lecture, écriture, et exécution
"repertory/" n'est pas accessible par dev en lecture
root@serveur1:~# sh test-fichier.sh emptyFIle
emptyFIle est un fichier ordinaire et est vide
"emptyFIle" n'est pas totalement accessible par root
"emptyFIle" n'est pas accessible par dev en lecture
```

# Afficher le contenu d'un repertoire

cf(https://superuser.com/questions/335376/how-to-list-folders-using-bash-commands)

- Après avoir vérifié le nombre d'argument on commence par vérifier que le paramètre donné est bien un repertoire.

- Ensuite à l'aide de la commande trouver sur superuser il est facile de séléctionner de n'afficher que les dossier ou les fichier.

- Enfin j'ai rajouté `grep` afin de retirer le dossier donnée en argument à l'aide de `-v` car sans cela le paramètre est listé .

```
#!/bin/bash

# Vérification des arguments
if [ "$#" -ne 1 ]; then
  echo "Usage: <directory>"
  exit 1
fi

# Vérification que le paramètre est bien un répertoire
if [ ! -d "$1" ]; then
  echo "Usage: $0 must be a directory"
  exit 1
fi

# Affichage des fichiers
echo "####### fichiers dans $1"
find "$1" -maxdepth 1 -type f

# Affichage des répertoires
echo "####### repertoires dans $1"
find "$1" -maxdepth 1 -type d | grep -v "^$1$"

exit 0
```

Le résultat est :

```
####### fichiers dans repertory/
repertory/tot2222o.txt
repertory/toto.txt
####### repertoires dans repertory/
repertory/dossier
root@serveur1:~# ls repertory/
dossier  tot2222o.txt  toto.txt
root@serveur1:~#

```

# User

## Parcours normal

Le problème vient de la façon dont le fichier `/etc/passwd` est lu. Elle ne prend pas en compte les séparateurs de champ (:) et lit donc chaque ligne comme une seule entité.

- On commence donc par spécifier que le séparateur est ":" avec `IFS=:`
- On lit ensuite l'entrée standard avec l'option
- Les champs lu sont assigné à des variables (username, password, ui, ...)
- On Vérifie si l'uid est supérieur à 100. Si oui on renvoie le nom d'utilisateur.

```
#!/bin/bash

if [ "$#" -ne 0 ]; then
  echo "Usage: no parameter"
  exit
fi

# Parcourir chaque ligne de /etc/passwd
while IFS=: read username password uid gid description home shell; do
    # Vérifier si l'UID est supérieur à 100
    if [ "$uid" -gt 100 ]; then
        echo "$username"
    fi
done < /etc/passwd
```

Le résultat est :

```
nobody
systemd-network
systemd-timesync
avahi-autoipd
dev
sshd
```

## Awk

- Awk est un outil de traitement de texte et de données.

- L'option `-F` définit un séparateur ici ":".

- On a vu lors de l'élaboration du script suivant que l'uid est la troisième champ. Donc on regarde si il est supérieur à 100. Si oui on renvoie le premier champ qui est l'username

```
#!/bin/bash

# Utiliser awk pour filtrer les utilisateurs avec un UID supérieur à 100
awk -F: '$3 > 100 { print $1 }' /etc/passwd
```

Le résultat est la même que le script précédent.

# User exist

- On vérifie comme d'habitude le nombre d'argument.

- Afin de vérifier si le login ou l'UID sont dispo on va utiliser le fichier `/etc/passwd`. Comme nous l'avons vu auparavant dans ce fichier la première colonne correspond au username; la seconde sera ignoré ici et la troisième le user identifier.

- Il faut aussi savoir que l'option `-q` pour grep signifie `quiet`. Pour que la commande grep ne renvoie pas la résultat sur la sortie standard. Ici on va se charger nous même d'afficher les résultat à l'aide de `echo`.

- La première ligne vérifie le login. Pour ce faire on va chercher dans  `/etc/passwd` le login passé en paramètre. Si on le trouve alors on affiche le login et son id à l'aide de la commande `id -u "$1". Sinon on dit qu'il est disponible.

- Pour l'uid on fonctinne un peu de la même facon. Sauf que cette fois on va retrouver le login à l'aide de `getent passwd`.

(cf : https://superuser.com/questions/336275/find-out-if-user-name-exists)

```
#!/bin/bash

# Vérifie si le bon nombre d'arguments est passé
if [ "$#" -ne 2 ]; then
    echo "Usage: <login|username> <UID>"
    exit 1
fi

# Vérification du login
grep -q "^$1:" /etc/passwd && echo "Login '$1' existe avec UID $(id -u "$1")" || echo "Login '$1' es>

# Vérification de l'UID
grep -q ":$2:" /etc/passwd && echo "UID '$2' appartient à $(getent passwd "$2" | cut -d: -f1)" || ec>

exit 0
```

voici le résultat

```
Login 'dev' existe avec UID 1000
UID '101' appartient à avahi-autoipd
```

# Create User

Comme dans la question précédente je check si le user et le login existe séparememnt et que j'ai légérement dévié de la consigne je ne peux pas trop réutiliser ma commande ici.

Sinon j'aurai juste eu a rajouté : `userExist.sh <login> <UID>` au lieu de ma condition.

- On commence donc à vérifier à l'aide de la variable `$USER` que c'est bien root qui execute. Pour rajouter de la sécurité j'ai vérifié avec chmod que seul le root peut lancer le script.

- Ensuite à l'aide de `read` on peut poser des question à l'utilisateur et stocker la réponse dans des variables.

- Je vérifie ensuite à l'image du script précédent que l'utilisateur n'existe pas déjà.

- Enfin je vérifie que sont répertoire home n'existe pas déjà.

- Il ne me reste plus qu'a lancer la commande `useradd` avec tous les paramètres récoltés.

- Enfin je vérifie que `useradd` c'est bien déroulé et je renvoie le message approprié.

```
#!/bin/bash

# Vérifier si l'utilisateur courant est root
if [ "$USER" != "root" ]; then
  echo "Ce script doit être exécuté en tant que root."
  exit 1
fi

# Demander les informations nécessaires pour l'utilisateur
read -p "Entrez le login de l'utilisateur : " login
read -p "Entrez le nom de l'utilisateur : " nom
read -p "Entrez le prénom de l'utilisateur : " prenom
read -p "Entrez l'UID de l'utilisateur : " uid
read -p "Entrez le GID de l'utilisateur : " gid
read -p "Entrez des commentaires supplémentaires (optionnel) : " comments

if getent passwd "$login" > /dev/null 2>&1; then
  echo "L'utilisateur $login existe déjà."
  exit 1
fi

# Vérifier si le répertoire home existe déjà
if [ -d "/home/$login" ]; then
  echo "Le répertoire /home/$login existe déjà."
  exit 1
fi

# Créer l'utilisateur avec les informations fournies
useradd -m -d "/home/$login" -c "$comments" -u "$uid" -g "$gid" -s /bin/bash "$login"

# Vérifier si la création a réussi
if [ $? -eq 0 ]; then
  echo "L'utilisateur $login a été créé avec succès."
  exit 0
else
  echo "Échec de la création de l'utilisateur."
  exit 1
fi
```

Voila le résultat :

```
Entrez le login de l'utilisateur : jcarmack
Entrez le nom de l'utilisateur : John
Entrez le prénom de l'utilisateur : Carmack
Entrez l'UID de l'utilisateur : 10981
Entrez le GID de l'utilisateur : 2
Entrez des commentaires supplémentaires (optionnel) : J'ai dev doom
L'utilisateur jcarmack a été créé avec succès.
```

# Lecture au clavier

Comme expliquer précedemment `read` me permet de poser des questions à l'utilisateur et de stocker le contenu de la réponse. Ainsi le "script" donné nous demande d'écrire notre nom puis nous le renvoie.

- Pour quitter `more` il faut appuyer sur `q`
- Pour avancer d'une ligne il faut appuyer sur `entrée`
- Pour avancer d'une page il faut appuyer sur `espace`
- Pour remonter d'une page `flèche du haut` ou `b` fonctionne
- Pour faire une recherche on fait `/ceQueJeRecherche` et `n` pour passer à l'occurence suivante

## Script de lecture

- On vérifie le nombre d'argument puis que cette arguement est un répertoire.

- Après on boucle sur ce répertoire ensuite on vérifie si le i-ème résultat est un fichier et si c'est un fichier de texte.

- Si oui on demande a l'utilisateur si il veut visualiser ou non si oui on lui affiche avec `more`.
- Si non on lui affiche un message tout de même.

```
#!/bin/bash

# Vérifier si un argument est passé
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <repertory>"
    exit 1
fi

# Vérifier si le répertoire existe
if [ ! -d "$1" ]; then
    echo "Le répertoire spécifié n'existe pas."
    exit 1
fi

# Lister les fichiers texte dans le répertoire
for file in "$1"/*; do
    # Vérifier si c'est un fichier régulier et s'il est de type texte
    if [ -f "$file" ] && file "$file" | grep -q "text"; then
        # Poser la question à l'utilisateur
        read -p "Voulez-vous visualiser le fichier $(basename "$file") ? (y/n) " response
        if [[ "$response" == "y" ]]; then
            more "$file"  # Afficher le fichier page par page
        else
            echo "Fichier non visualisé."
        fi
    fi
done
```

Voici le résultat :

```
Voulez-vous visualiser le fichier tot2222o.txt ? (y/n) y
dljqdljqlkdjlkjdlkjqkldqnd,nqdn;qnd;qn;dn;qdnqndjq;d

```

# Appréciations

```
#!/bin/bash

- Tout d'abord on se met dans une boucle while. Dans cette boucle on lit ce que donne l'utilisateur.

- Si il appuie sur `q` on sort du programme.

- Si les données en entrée ne sont pas des chiffres ou ne sont pas compris entre 0 et 20. On renvoie un message d'erreur.

- Enfin il ne nous reste plus qu'a comparer le résultat avec des `if`.

while true; do
    echo "Veuillez saisir une note (ou appuyez sur 'q' pour quitter) : "
    read input

    if [[ "$input" == "q" ]]; then
        echo "Programme terminé."
        break
    elif ! [[ "$input" =~ ^[0-9]+$ ]] || [ "$input" -lt 0 ] || [ "$input" -gt 20 ]; then
        echo "Veuillez entrer une note valide entre 0 et 20."
        continue
    fi

    if [ "$input" -ge 16 ]; then
        echo "Très bien"
    elif [ "$input" -ge 14 ]; then
        echo "Bien"
    elif [ "$input" -ge 12 ]; then
        echo "Assez bien"
    elif [ "$input" -ge 10 ]; then
        echo "Moyen"
    else
        echo "Insuffisant"
    fi
done
```

Voila le résultat :

```
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
a
Veuillez entrer une note valide entre 0 et 20.
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
21
Veuillez entrer une note valide entre 0 et 20.
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
1
Insuffisant
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
12
Assez bien
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
20
Très bien
Veuillez saisir une note (ou appuyez sur 'q' pour quitter) :
q
Programme terminé.
```
